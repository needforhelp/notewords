<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ä¾¿ç­¾å¢™</title>
    <!-- å¼•å…¥ Supabase å®¢æˆ·ç«¯åº“ (å·²ç§»é™¤ï¼Œå› ä¸ºåˆ‡æ¢åˆ° localStorage) -->
    <!-- <script src="./supabase.min.js"></script> -->
    <style>
        /* CSS Variables for theming */
        :root {
            /* Light Mode Variables */
            --body-bg-color-light: #ffffff;
            --bg-color-light: linear-gradient(0deg, #eee 1px, transparent 0),
                linear-gradient(90deg, #eee 1px, transparent 0);
            --bg-size-light: 30px 30px;
            --text-color-light: #333;
            --card-border-color-light: rgba(0, 0, 0, 0.08);
            --card-shadow-color-light: rgba(0, 0, 0, 0.2);
            --card-header-bg-light: rgba(255, 255, 255, 0.7);
            --control-border-color-light: rgba(0, 0, 0, 0.08);
            --control-bg-color-light: #ccc;
            --card-title-color-light: #000000;
            --card-body-color-light: rgba(0, 0, 0, 0.72);
            --grid-line-color-light: #eee;
            --edit-tool-text-color-light: #000000;

            /* Dark Mode Variables */
            --body-bg-color-dark: #1a1a1a;
            --bg-color-dark: linear-gradient(0deg, #333 1px, transparent 0),
                linear-gradient(90deg, #333 1px, transparent 0);
            --bg-size-dark: 30px 30px;
            --text-color-dark: #eee;
            --card-border-color-dark: rgba(255, 255, 255, 0.15);
            --card-shadow-color-dark: rgba(0, 0, 0, 0.5);
            --card-header-bg-dark: rgba(166, 166, 166, 0.4);
            --control-border-color-dark: rgba(255, 255, 255, 0.2);
            --control-bg-color-dark: #555;
            --card-title-color-dark: #000000;
            --card-body-color-dark: rgba(125, 125, 125, 0.85);
            --grid-line-color-dark: #333;
            --edit-tool-text-color-dark: #000000;

            /* Default to dark mode variables */
            --body-bg-color: var(--body-bg-color-dark);
            --bg-image: var(--bg-color-dark);
            --bg-size: var(--bg-size-dark);
            --text-color: var(--text-color-dark);
            --card-border-color: var(--card-border-color-dark);
            --card-shadow-color: var(--card-shadow-color-dark);
            --card-header-bg: var(--card-header-bg-dark);
            --control-border-color: var(--control-border-color-dark);
            --control-bg-color: var(--control-bg-color-dark);
            --card-title-color: var(--card-title-color-dark);
            --card-body-color: var(--card-body-color-dark);
            --grid-line-color: var(--grid-line-color-dark);
            --edit-tool-text-color: var(--edit-tool-text-color-dark);
        }

        /* Override variables for light mode */
        body.light-mode {
            --body-bg-color: var(--body-bg-color-light);
            --bg-image: var(--bg-color-light);
            --bg-size: var(--bg-size-light);
            --text-color: var(--text-color-light);
            --card-border-color: var(--card-border-color-light);
            --card-shadow-color: var(--card-shadow-color-light);
            --card-header-bg: var(--card-header-bg-light);
            --control-border-color: var(--control-border-color-light);
            --control-bg-color: var(--control-bg-color-light);
            --card-title-color: var(--card-title-color-light);
            --card-body-color: var(--card-body-color-light);
            --grid-line-color: var(--grid-line-color-light);
            --edit-tool-text-color: var(--edit-tool-text-color-light);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--body-bg-color);
            background-image: linear-gradient(0deg, var(--grid-line-color) 1px, transparent 0),
                linear-gradient(90deg, var(--grid-line-color) 1px, transparent 0);
            background-size: var(--bg-size);
            color: var(--text-color);
            min-height: 100dvh;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease, background-image 0.3s ease;
        }

        body.has-maximized-card {
            overflow: hidden;
        }

        body.is-mobile {
            overflow-y: auto;
        }

        #board {
            position: relative;
            width: 100vw;
            height: 100dvh;
            overflow: hidden;
        }

        body.is-mobile #board {
            height: auto;
            min-height: 100dvh;
        }

        .card {
            position: absolute;
            /* é»˜è®¤é«˜åº¦æ”¹ä¸º autoï¼Œè®©å†…å®¹æ’‘å¼€ï¼ŒåŒæ—¶ä¿ç•™æœ€å°é«˜åº¦ */
            height: auto;
            min-height: 140px; /* æœ€å°é«˜åº¦ */
            border-radius: 12px;
            box-shadow: 0 16px 35px var(--card-shadow-color);
            background: #fff;
            border: 1px solid var(--card-border-color);
            overflow: hidden; /* ç¡®ä¿å†…å®¹ä¸ä¼šè¶…å‡ºåœ†è§’è¾¹æ¡† */
            opacity: 0;
            transform-origin: center;
            transition: transform 0.35s ease, opacity 0.35s ease, left 0.35s ease,
                top 0.35s ease, width 0.35s ease, height 0.35s ease, /* height åŠ¨ç”» */
                border-radius 0.35s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            cursor: move;
            display: flex;
            flex-direction: column;
        }

        .card.dragging {
            transition: none;
            box-shadow: 0 22px 45px rgba(0, 0, 0, 0.35);
        }

        .card.editing {
            cursor: text !important;
        }

        .card.maximized {
            position: fixed;
            inset: 0;
            width: 100vw !important;
            height: 100vh !important;
            height: 100dvh !important;
            border-radius: 0;
            box-shadow: 0 28px 60px rgba(0, 0, 0, 0.4);
            cursor: auto;
        }

        .card.selected {
            border: 2px solid #007acc !important;
            box-shadow: 0 0 20px rgba(0, 122, 204, 0.5) !important;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: var(--card-header-bg);
            cursor: move;
            user-select: none;
            touch-action: pan-y;
            transition: background 0.3s ease;
            flex-shrink: 0; /* ç¡®ä¿æ ‡é¢˜æ ä¸ä¼šè¢«æŒ¤å‹ */
        }

        .card.editing .card-header {
            cursor: text !important;
        }

        .card-header.dragging {
            cursor: grabbing;
        }

        .window-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
            z-index: 10;
        }

        .window-controls .control {
            position: relative;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid var(--control-border-color);
            background: var(--control-bg-color);
            cursor: pointer;
            outline: none;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        .window-controls .control.close {
            background: #ff5f57;
            border-color: #e0443e;
        }

        .window-controls .control.maximize {
            background: #28c840;
            border-color: #1aab2c;
        }

        .window-controls .control.color-change {
            background: #febb2e;
            border-color: #dea123;
        }

        .window-controls .control.copy {
            background: #007acc;
            border-color: #0066b3;
        }

        .window-controls .control::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .card-header:hover .window-controls .control::after {
            opacity: 0.8;
        }

        .window-controls .control.close::after {
            content: 'Ã—';
            width: auto;
            height: auto;
            background: none;
            font-size: 10px;
            line-height: 1;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
        }

        .window-controls .control.maximize::after {
            width: 6px;
            height: 6px;
            background: linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.9) 0%,
                rgba(255, 255, 255, 0.9) 45%,
                transparent 45%,
                transparent 55%,
                rgba(255, 255, 255, 0.9) 55%,
                rgba(255, 255, 255, 0.9) 100%
            );
        }

        .window-controls .control.color-change::after {
            content: 'ğŸ¨';
            font-size: 8px;
            line-height: 1;
            color: rgba(255, 255, 255, 0.9);
        }

        .window-controls .control.copy::after {
            content: 'ğŸ“‹';
            font-size: 8px;
            line-height: 1;
            color: rgba(255, 255, 255, 0.9);
        }

        .card-title {
            font-size: 17px;
            font-weight: 600;
            color: var(--card-title-color);
            padding-left: 10px;
            flex: 1;
            transition: color 0.3s ease;
            user-select: text;
            outline: none;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0;
            word-break: break-word; /* ç¡®ä¿æ ‡é¢˜æ–‡å­—æ¢è¡Œ */
        }

        .card-title:empty:before {
            content: 'æ ‡é¢˜';
            color: var(--card-body-color);
            opacity: 0.5;
            font-weight: 400;
        }

        .card-title:focus {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .card.maximized .card-title {
            display: inline-block;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: text;
            transition: all 0.2s ease;
        }

        .card.maximized .card-title:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .card.maximized .card-title:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .card-body-container {
            flex: 1; /* ç¡®ä¿å†…å®¹åŒºåŸŸå æ®å‰©ä½™ç©ºé—´ */
            display: flex;
            flex-direction: column;
            position: relative;
            padding-bottom: 16px; /* ä¸º resize-handle ç•™å‡ºç©ºé—´ */
        }

        .card-body {
            padding: 0 16px; /* è°ƒæ•´ padding */
            font-size: 16px;
            line-height: 1.4;
            font-weight: 600;
            color: var(--card-body-color);
            word-break: break-word;
            overflow-wrap: anywhere;
            white-space: pre-wrap; /* ä¿æŒè¾“å…¥æ—¶çš„æ¢è¡Œå’Œç©ºæ ¼ */
            transition: color 0.3s ease;
            user-select: text;
            flex: 1; /* ç¡®ä¿å†…å®¹ä¸»ä½“å æ®å‰©ä½™ç©ºé—´ */
            outline: none;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            margin: 0 0 0 0; /* ç§»é™¤åº•éƒ¨ marginï¼Œç”± container ç»Ÿä¸€ç®¡ç† */
            overflow-y: auto; /* å…³é”®ï¼šå†…å®¹æº¢å‡ºæ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
            min-height: 60px; /* ç¡®ä¿ body æœ‰æœ€å°é«˜åº¦ */
        }

        .card-body:empty:before {
            content: 'åŒå‡»æ·»åŠ å†…å®¹';
            color: var(--card-body-color);
            opacity: 0.5;
            font-weight: 400;
        }

        .card-body:focus {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .card.maximized .card-body-container {
            flex: 1;
            display: flex;
            flex-direction: column; /* ä¿æŒ column */
            align-items: center; /* å±…ä¸­å†…å®¹ */
            justify-content: flex-start; /* ä»é¡¶éƒ¨å¼€å§‹ */
            width: 100%;
            height: 100%;
            padding-bottom: 0; /* æœ€å¤§åŒ–æ—¶ä¸éœ€è¦åº•éƒ¨ padding */
        }

        .card.maximized .card-body {
            flex: 1;
            width: 100%;
            height: 100%;
            text-align: center;
            padding: clamp(32px, min(10vw, 10vh), 128px);
            padding-top: clamp(72px, min(14vw, 14vh), 192px);
            font-size: clamp(48px, min(18vw, 18vh), 200px);
            line-height: 1.2;
            white-space: pre-wrap;
            overflow-y: auto;
            outline: none;
            cursor: text;
            content-editable: true;
            margin: 0;
            display: flex; /* å†…éƒ¨ flex å¸ƒå±€ */
            align-items: flex-start; /* ä¿æŒå†…å®¹é¡¶éƒ¨å¯¹é½ */
            justify-content: center; /* æ°´å¹³å±…ä¸­ */
        }

        /* ç¡®ä¿æœ€å¤§åŒ–ä¾¿ç­¾ä¸­çš„å†…å®¹æ–‡å­—ï¼ˆåŒ…æ‹¬å†…éƒ¨æ ‡ç­¾å¦‚<span>ï¼‰èƒ½æ­£ç¡®ç»§æ‰¿å¹¶éšè§†å£å¤§å°å˜åŒ– */
        .card.maximized .card-body * {
            font-size: inherit !important;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .card:hover .resize-handle,
        .card.resizing .resize-handle {
            opacity: 0.5;
        }

        .resize-handle::before {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 0 10px 10px;
            border-color: transparent transparent var(--card-body-color) transparent;
            opacity: 0.4;
        }

        .edit-tools {
            display: none;
            gap: 4px;
            margin-left: 8px;
        }

        .card.maximized .edit-tools {
            display: flex;
        }

        .edit-tool-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            color: var(--edit-tool-text-color);
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
        }

        .edit-tool-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .edit-tool-btn.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .card-body.strikethrough {
            text-decoration: line-through;
        }

        .card-body.underline {
            text-decoration: underline;
        }

        .card-body.wavy {
            text-decoration: underline;
            text-decoration-style: wavy;
            text-decoration-color: #ff6b6b;
        }

        @media (max-width: 768px) {
            .card {
                width: 180px;
                min-height: 100px; /* ç§»åŠ¨ç«¯æœ€å°é«˜åº¦ */
                border-radius: 10px;
            }

            .card-body {
                padding: 14px;
                font-size: 14px;
            }

            .card-title {
                font-size: 14px;
            }

            .resize-handle {
                display: none;
            }
        }

        #theme-toggle {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: var(--card-header-bg);
            border: 1px solid var(--card-border-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            z-index: 1000001;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, transform 0.15s ease;
            color: var(--text-color);
            touch-action: none;
            user-select: none;
        }

        #theme-toggle:hover {
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
        }

        #theme-toggle:active {
            transform: scale(0.95);
        }

        #theme-toggle.dragging {
            transition: none;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
            z-index: 1000002;
            cursor: grabbing;
        }

        .card.editing .card-body {
            cursor: text;
            background: rgba(255, 255, 255, 0.1);
        }

        .card.editing .card-title {
            cursor: text;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        /* æ¡†é€‰ç›¸å…³æ ·å¼ */
        .selection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999999;
            pointer-events: none;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #007acc;
            background: rgba(0, 122, 204, 0.1);
            pointer-events: none;
        }

        .delete-selected-btn {
            position: fixed;
            bottom: 60px;
            right: 15px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            z-index: 1000000;
            display: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .delete-selected-btn:hover {
            background: #ff6666;
            transform: translateY(-2px);
        }

        .delete-selected-btn.show {
            display: block;
        }

        .selection-mode-hint {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000001;
            display: none;
        }

        .selection-mode-hint.show {
            display: block;
        }

        /* å¤åˆ¶æˆåŠŸæç¤º */
        .copy-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000000;
        }

        .copy-tooltip.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="board"></div>
    <button id="theme-toggle" aria-label="åˆ‡æ¢ä¸»é¢˜"></button>
    <div class="selection-overlay" id="selectionOverlay"></div>
    <button class="delete-selected-btn" id="deleteSelectedBtn">åˆ é™¤é€‰ä¸­çš„ä¾¿ç­¾</button>
    <div class="selection-mode-hint" id="selectionHint">æŒ‰ä½Ctrlå¹¶æ‹–åŠ¨é¼ æ ‡æ¡†é€‰ä¾¿ç­¾è¿›è¡Œæ‰¹é‡åˆ é™¤</div>

    <script>
        // --- Supabase åˆå§‹åŒ– (å·²ç§»é™¤ï¼Œåˆ‡æ¢åˆ° localStorage) ---
        // const SUPABASE_URL = 'https://wketotdrvgmijhywfqbv.supabase.co';
        // const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndrZXRvdGRydmdtaWpoeXdmcWJ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI2NDk4NjksImV4cCI6MjA3ODIyNTg2OX0.P5lXhdebBpNOO3sjGCiALqD4xpzL1dKOKa7-9uYJQzg';
        // const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const board = document.getElementById('board')
        const themeToggleButton = document.getElementById('theme-toggle')
        const selectionOverlay = document.getElementById('selectionOverlay')
        const deleteSelectedBtn = document.getElementById('deleteSelectedBtn')
        const selectionHint = document.getElementById('selectionHint')

        const messages = [
            'åŒå‡»èƒŒæ™¯æ–°å»ºä¾¿ç­¾',
            'å³é”®ç‚¹å‡»ä¾¿ç­¾æ–‡å­—å¯ç›´æ¥ç¼–è¾‘',
            'åŒå‡»ä¾¿ç­¾æ ‡é¢˜æ å¯å…¨å±ç¼–è¾‘',
            'ctrlï¼‹æ¡†é€‰è¿›è¡Œæ‰¹é‡åˆ é™¤',
        ]

        // å¢åŠ ç°è‰²å’Œç™½è‰²
        const colors = [
            '#ffe0e3', // Light pink
            '#c7f0ff', // Light blue
            '#ffd8a8', // Light orange
            '#d9f2d9', // Light green
            '#e5d7ff', // Light purple
            '#f9f7d9', // Light yellow
            '#d2f0f8', // Pale blue
            '#ffd4f5', // Pinkish purple
            '#f0f0f0', // Light gray (æ–°å¢)
            '#ffffff'  // White (æ–°å¢)
        ]

        // æ›´å¤šé•¿å®½æ¯”çš„ä¾¿ç­¾å½¢çŠ¶ (å®½, é«˜)
        const initialCardDimensions = [
            { width: 220, height: 140 }, // é»˜è®¤å°ºå¯¸
            { width: 180, height: 180 }, // æ­£æ–¹å½¢
            { width: 260, height: 120 }, // å®½æ‰
            { width: 160, height: 200 }, // çª„é«˜
            { width: 200, height: 100 }, // æ›´æ‰
            { width: 240, height: 160 }  // ç¨å¤§
        ];

        const cardStates = new WeakMap()
        const MAXIMIZED_LAYER = 1000000
        let activeMaximizedCard = null
        const pointerMediaQuery = window.matchMedia('(pointer: coarse)')
        let isMobile =
            pointerMediaQuery.matches || window.innerWidth <= 768
        let maxCards = isMobile ? 120 : 180
        let zIndexCursor = 200
        let currentMessageIndex = 0;

        // æ¡†é€‰ç›¸å…³çŠ¶æ€
        let isSelecting = false
        let selectionStartX = 0
        let selectionStartY = 0
        let selectionBox = null
        let selectedCards = new Set()

        // ä¸»é¢˜æŒ‰é’®æ‹–åŠ¨ç›¸å…³çŠ¶æ€
        let themeButtonDragging = false;
        let themeButtonOffsetX = 0;
        let themeButtonOffsetY = 0;
        let themeButtonStartX = 0;
        let themeButtonStartY = 0;
        let themeButtonHasMoved = false;
        let themeButtonClickTimeout = null;

        // localStorage é”®å
        const LOCAL_STORAGE_KEY = 'sticky_notes';

        document.body.classList.toggle('is-mobile', isMobile)

        function randomFrom(array) {
            return array[Math.floor(Math.random() * array.length)]
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max)
        }

        // Helper to generate a unique ID for localStorage
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        function applyTransform(card, state) {
            const scale = state.scale ?? 1
            const angle = state.angle ?? 0
            card.style.transform = `scale(${scale}) rotate(${angle}deg)`
        }

        function bringToFront(card) {
            if (card === activeMaximizedCard) {
                card.style.zIndex = MAXIMIZED_LAYER
                return
            }

            zIndexCursor += 1
            if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER) {
                zIndexCursor = MAXIMIZED_LAYER - 1
            }

            card.style.zIndex = zIndexCursor
        }

        function updateBodyMaximizedState() {
            document.body.classList.toggle(
                'has-maximized-card',
                Boolean(activeMaximizedCard)
            )
        }

        function syncMobileMode() {
            const nextIsMobile =
                pointerMediaQuery.matches || window.innerWidth <= 768
            if (nextIsMobile === isMobile) return

            isMobile = nextIsMobile
            maxCards = isMobile ? 120 : 180
            document.body.classList.toggle('is-mobile', isMobile)
        }

        function handleBoardClick(event) {
            const control = event.target.closest('.control, .edit-tool-btn')
            if (!control) return

            const card = control.closest('.card')
            if (!card || !board.contains(card)) return

            event.preventDefault()

            if (control.classList.contains('close')) {
                closeCard(card)
            } else if (control.classList.contains('maximize')) {
                toggleMaximize(card)
            } else if (control.classList.contains('color-change')) {
                cycleCardColor(card)
            } else if (control.classList.contains('copy')) {
                copyCardContent(card)
            } else if (control.classList.contains('edit-tool-btn')) {
                handleEditToolClick(control, card)
            }
        }

        // å¤åˆ¶ä¾¿ç­¾å†…å®¹åŠŸèƒ½
        function copyCardContent(card) {
            const bodyElement = card.querySelector('.card-body')
            const content = bodyElement.innerText || bodyElement.textContent
            
            if (content.trim()) {
                navigator.clipboard.writeText(content.trim()).then(() => {
                    showCopyTooltip(card, 'å·²å¤åˆ¶å†…å®¹')
                }).catch(() => {
                    // é™çº§æ–¹æ¡ˆ
                    const textarea = document.createElement('textarea')
                    textarea.value = content.trim()
                    textarea.style.position = 'fixed'
                    textarea.style.opacity = '0'
                    document.body.appendChild(textarea)
                    textarea.select()
                    document.execCommand('copy')
                    document.body.removeChild(textarea)
                    showCopyTooltip(card, 'å·²å¤åˆ¶å†…å®¹')
                })
            } else {
                showCopyTooltip(card, 'å†…å®¹ä¸ºç©º')
            }
        }

        // æ˜¾ç¤ºå¤åˆ¶æç¤º
        function showCopyTooltip(card, message) {
            let tooltip = card.querySelector('.copy-tooltip')
            if (!tooltip) {
                tooltip = document.createElement('div')
                tooltip.className = 'copy-tooltip'
                card.appendChild(tooltip)
            }
            
            tooltip.textContent = message
            tooltip.style.top = '40px'
            tooltip.style.left = '50%'
            tooltip.style.transform = 'translateX(-50%)'
            tooltip.classList.add('show')
            
            setTimeout(() => {
                tooltip.classList.remove('show')
            }, 1500)
        }

        // å…¨å±€é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨äºæ¡†é€‰åŠŸèƒ½
        function handleGlobalPointerDown(event) {
            if (event.ctrlKey || event.metaKey) {
                event.preventDefault()
                event.stopPropagation()
                
                const card = event.target.closest('.card')
                if (card) {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯ä¾¿ç­¾ï¼Œä¸è§¦å‘æ¡†é€‰ï¼Œå…è®¸ä¾¿ç­¾å†…éƒ¨äº¤äº’
                    return
                }
                
                startSelection(event)
                return
            }
        }

        function handleBoardPointerDown(event) {
            if (isSelecting) {
                // å¦‚æœæ­£åœ¨æ¡†é€‰ï¼Œä¸è§¦å‘ä¾¿ç­¾æ‹–åŠ¨æˆ–è°ƒæ•´å¤§å°
                return
            }

            const card = event.target.closest('.card')
            if (!card || !board.contains(card)) return

            const control = event.target.closest('.control, .edit-tool-btn, .resize-handle')
            const pointerType = event.pointerType || 'mouse'
            const isPrimaryPointer = event.isPrimary !== false

            const state = cardStates.get(card)
            
            if (
                !control &&
                pointerType !== 'touch' &&
                isPrimaryPointer &&
                !state?.editing
            ) {
                startDrag(event, card)
                return
            }

            if (event.target.closest('.resize-handle')) {
                startResize(event, card)
                return
            }

            bringToFront(card)
        }

        function handleBoardDoubleClick(event) {
            const header = event.target.closest('.card-header')
            if (!header || event.target.closest('.control, .edit-tool-btn')) return

            const card = header.closest('.card')
            if (!card || !board.contains(card)) return

            toggleMaximize(card)
        }

        function handleBoardBackgroundDoubleClick(event) {
            if (event.target === board) {
                createCard(null, event.clientX, event.clientY) // Pass null for cardData to indicate new card
            }
        }

        function handleContextMenu(event) {
            const card = event.target.closest('.card')
            if (!card || !board.contains(card)) return

            const state = cardStates.get(card)
            if (!state || state.closing || state.maximized) return

            const bodyElement = card.querySelector('.card-body')
            const titleElement = card.querySelector('.card-title')

            if (event.target === bodyElement || event.target === titleElement) {
                event.preventDefault()
                enableInlineEdit(card, event.target)
            }
        }

        async function enableInlineEdit(card, element) {
            const state = cardStates.get(card)
            if (!state) return

            state.editing = true
            card.classList.add('editing')
            
            element.contentEditable = 'true'
            element.spellcheck = false
            
            const selection = window.getSelection()
            const range = document.createRange()
            if (element.textContent.trim()) {
                range.selectNodeContents(element)
            } else {
                range.setStart(element, 0)
                range.setEnd(element, 0)
            }
            selection.removeAllRanges()
            selection.addRange(range)
            
            element.focus()
            
            // ç«‹å³ä¿å­˜ä¸€æ¬¡ï¼Œä»¥é˜²ç”¨æˆ·ä¸è¾“å…¥ç›´æ¥å¤±ç„¦
            await saveCardToLocalStorage(card);

            const handleInput = () => {
                saveCardToLocalStorage(card);
            }

            const handleBlur = () => {
                element.contentEditable = 'false'
                card.classList.remove('editing')
                state.editing = false
                element.removeEventListener('input', handleInput)
                element.removeEventListener('blur', handleBlur)
                // ç¡®ä¿å¤±ç„¦æ—¶ä¹Ÿä¿å­˜ä¸€æ¬¡
                saveCardToLocalStorage(card);
            }

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    if (element.classList.contains('card-body')) {
                        e.preventDefault()
                        const selection = window.getSelection()
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0)
                            const br = document.createElement('br')
                            range.insertNode(br)
                            range.setStartAfter(br)
                            range.collapse(true)
                            selection.removeAllRanges()
                            selection.addRange(range)
                        }
                    } else {
                        // æ ‡é¢˜æ æŒ‰ Enter é€€å‡ºç¼–è¾‘
                        element.blur()
                    }
                } else if (e.key === 'Escape') {
                    element.blur()
                }
            }

            element.addEventListener('input', handleInput)
            element.addEventListener('blur', handleBlur)
            element.addEventListener('keydown', handleKeyDown)
        }

        // æ¡†é€‰åŠŸèƒ½
        function startSelection(event) {
            isSelecting = true
            selectionStartX = event.clientX
            selectionStartY = event.clientY
            
            selectionBox = document.createElement('div')
            selectionBox.className = 'selection-box'
            selectionBox.style.left = selectionStartX + 'px'
            selectionBox.style.top = selectionStartY + 'px'
            selectionBox.style.width = '0px'
            selectionBox.style.height = '0px'
            selectionOverlay.appendChild(selectionBox)
            
            selectionHint.classList.add('show')
            
            document.addEventListener('pointermove', handleSelectionMove)
            document.addEventListener('pointerup', endSelection)
            
            event.preventDefault()
        }

        function handleSelectionMove(event) {
            if (!isSelecting || !selectionBox) return
            
            const currentX = event.clientX
            const currentY = event.clientY
            
            const left = Math.min(selectionStartX, currentX)
            const top = Math.min(selectionStartY, currentY)
            const width = Math.abs(currentX - selectionStartX)
            const height = Math.abs(currentY - selectionStartY)
            
            selectionBox.style.left = left + 'px'
            selectionBox.style.top = top + 'px'
            selectionBox.style.width = width + 'px'
            selectionBox.style.height = height + 'px'
            
            updateSelectedCards(left, top, width, height)
        }

        function updateSelectedCards(left, top, width, height) {
            document.querySelectorAll('.card.selected').forEach(card => {
                card.classList.remove('selected')
            })
            selectedCards.clear()
            
            const cards = document.querySelectorAll('.card')
            cards.forEach(card => {
                const rect = card.getBoundingClientRect()
                
                // æ£€æŸ¥ä¾¿ç­¾æ˜¯å¦ä¸é€‰æ‹©æ¡†é‡å 
                if (!(rect.right < left || 
                      rect.left > left + width || 
                      rect.bottom < top || 
                      rect.top > top + height)) {
                    card.classList.add('selected')
                    selectedCards.add(card)
                }
            })
            
            if (selectedCards.size > 0) {
                deleteSelectedBtn.classList.add('show')
                deleteSelectedBtn.textContent = `åˆ é™¤é€‰ä¸­çš„ä¾¿ç­¾ (${selectedCards.size})`
            } else {
                deleteSelectedBtn.classList.remove('show')
            }
        }

        function endSelection() {
            isSelecting = false
            
            if (selectionBox) {
                selectionBox.remove()
                selectionBox = null
            }
            
            selectionHint.classList.remove('show')
            
            document.removeEventListener('pointermove', handleSelectionMove)
            document.removeEventListener('pointerup', endSelection)
        }

        async function deleteSelectedCards() {
            if (selectedCards.size === 0) return
            
            // ä½¿ç”¨ Promise.all ç­‰å¾…æ‰€æœ‰åˆ é™¤æ“ä½œå®Œæˆ
            const deletePromises = Array.from(selectedCards).map(card => closeCard(card));
            await Promise.all(deletePromises);

            selectedCards.clear()
            deleteSelectedBtn.classList.remove('show')
        }

        // æ”¹è¿›çš„ä¸»é¢˜æŒ‰é’®æ‹–åŠ¨å¤„ç†
        function handleThemeButtonPointerDown(event) {
            if (event.target === themeToggleButton) {
                // è®°å½•åˆå§‹ä½ç½®
                themeButtonStartX = event.clientX
                themeButtonStartY = event.clientY
                themeButtonOffsetX = event.clientX - themeToggleButton.offsetLeft
                themeButtonOffsetY = event.clientY - themeToggleButton.offsetTop
                themeButtonDragging = true
                themeButtonHasMoved = false
                
                // æ¸…é™¤ä¹‹å‰çš„ç‚¹å‡»å®šæ—¶å™¨
                if (themeButtonClickTimeout) {
                    clearTimeout(themeButtonClickTimeout)
                    themeButtonClickTimeout = null
                }
                
                themeToggleButton.classList.add('dragging')
                
                // æ·»åŠ ç‚¹å‡»å»¶è¿Ÿæ£€æµ‹
                themeButtonClickTimeout = setTimeout(() => {
                    if (!themeButtonHasMoved && themeButtonDragging) {
                        // å¦‚æœæ²¡æœ‰ç§»åŠ¨ï¼Œè®¾ç½®ä¸ºç‚¹å‡»çŠ¶æ€
                        themeButtonHasMoved = false
                    }
                }, 150)
            }
        }

        function handleThemeButtonPointerMove(event) {
            if (!themeButtonDragging) return

            const deltaX = Math.abs(event.clientX - themeButtonStartX)
            const deltaY = Math.abs(event.clientY - themeButtonStartY)
            
            // ç§»åŠ¨é˜ˆå€¼è®¾ä¸ºè¾ƒå°å€¼ï¼Œæ›´æ•æ„Ÿåœ°æ£€æµ‹æ‹–åŠ¨
            if (deltaX > 3 || deltaY > 3) {
                themeButtonHasMoved = true
                
                // æ¸…é™¤ç‚¹å‡»æ£€æµ‹å®šæ—¶å™¨
                if (themeButtonClickTimeout) {
                    clearTimeout(themeButtonClickTimeout)
                    themeButtonClickTimeout = null
                }
            }

            // åªæœ‰åœ¨ç¡®è®¤æ˜¯æ‹–åŠ¨åæ‰ç§»åŠ¨æŒ‰é’®
            if (themeButtonHasMoved) {
                const newX = event.clientX - themeButtonOffsetX
                const newY = event.clientY - themeButtonOffsetY

                const maxX = window.innerWidth - themeToggleButton.offsetWidth
                const maxY = window.innerHeight - themeToggleButton.offsetHeight

                themeToggleButton.style.left = clamp(newX, 0, maxX) + 'px'
                themeToggleButton.style.top = clamp(newY, 0, maxY) + 'px'
                themeToggleButton.style.right = 'auto'
                themeToggleButton.style.bottom = 'auto'
            }
        }

        function handleThemeButtonPointerUp(event) {
            if (!themeButtonDragging) return

            themeButtonDragging = false
            themeToggleButton.classList.remove('dragging')
            
            // æ¸…é™¤ç‚¹å‡»æ£€æµ‹å®šæ—¶å™¨
            if (themeButtonClickTimeout) {
                clearTimeout(themeButtonClickTimeout)
                themeButtonClickTimeout = null
            }
            
            // å¦‚æœæ²¡æœ‰ç§»åŠ¨ï¼Œåˆ™è§¦å‘ç‚¹å‡»äº‹ä»¶
            if (!themeButtonHasMoved) {
                setDarkMode(!isDarkMode)
            }
            
            // é‡ç½®ç§»åŠ¨çŠ¶æ€
            themeButtonHasMoved = false
        }

        board.addEventListener('click', handleBoardClick)
        board.addEventListener('pointerdown', handleBoardPointerDown)
        board.addEventListener('dblclick', handleBoardDoubleClick)
        board.addEventListener('dblclick', handleBoardBackgroundDoubleClick)
        board.addEventListener('contextmenu', handleContextMenu)

        themeToggleButton.addEventListener('pointerdown', handleThemeButtonPointerDown)
        document.addEventListener('pointermove', handleThemeButtonPointerMove)
        document.addEventListener('pointerup', handleThemeButtonPointerUp)

        deleteSelectedBtn.addEventListener('click', deleteSelectedCards)

        // --- localStorage æ•°æ®æ“ä½œå‡½æ•° ---

        /**
         * ä¿å­˜æˆ–æ›´æ–°ä¾¿ç­¾åˆ° localStorage (Upsert)
         * @param {HTMLElement} card - è¦ä¿å­˜çš„ä¾¿ç­¾ DOM å…ƒç´ 
         */
        async function saveCardToLocalStorage(card) {
            const state = cardStates.get(card);
            if (!state) return;

            // è·å–å½“å‰ä¾¿ç­¾çš„å®é™…é«˜åº¦ï¼Œå¦‚æœç”¨æˆ·æ‰‹åŠ¨è°ƒæ•´è¿‡ï¼Œåˆ™ä¿å­˜è°ƒæ•´åçš„é«˜åº¦
            // å¦‚æœä¾¿ç­¾æ˜¯è‡ªåŠ¨æ’‘å¼€çš„ï¼Œåˆ™ä¿å­˜ nullï¼Œä»¥ä¾¿ä¸‹æ¬¡åŠ è½½æ—¶ä»è‡ªåŠ¨æ’‘å¼€
            const currentHeightStyle = card.style.height;
            const savedHeight = currentHeightStyle === 'auto' || currentHeightStyle === '' ? null : card.offsetHeight;

            const cardData = {
                id: state.id || generateUniqueId(), // Use existing ID or generate new one
                title: card.querySelector('.card-title').innerText,
                content: card.querySelector('.card-body').innerText,
                left: state.left,
                top: state.top,
                color: card.style.background,
                angle: state.angle,
                scale: state.scale,
                width: card.offsetWidth,
                height: savedHeight, // ä¿å­˜å½“å‰è®¡ç®—æˆ–ç”¨æˆ·è®¾ç½®çš„é«˜åº¦
                maximized: state.maximized,
                currentColorIndex: state.currentColorIndex
            };

            // Update state.id if it was newly generated
            state.id = cardData.id;

            let notes = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            const existingIndex = notes.findIndex(note => note.id === cardData.id);

            if (existingIndex > -1) {
                notes[existingIndex] = cardData; // Update existing card
            } else {
                notes.push(cardData); // Add new card
            }

            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(notes));
        }

        /**
         * ä» localStorage åˆ é™¤ä¾¿ç­¾
         * @param {string} cardId - è¦åˆ é™¤çš„ä¾¿ç­¾çš„ ID
         */
        async function deleteCardFromLocalStorage(cardId) {
            if (!cardId) return;

            let notes = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            notes = notes.filter(note => note.id !== cardId);
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(notes));
        }

        /**
         * ä» localStorage åŠ è½½æ‰€æœ‰ä¾¿ç­¾
         */
        async function loadCardsFromLocalStorage() {
            const notesString = localStorage.getItem(LOCAL_STORAGE_KEY);
            let notes = [];
            if (notesString) {
                try {
                    notes = JSON.parse(notesString);
                } catch (e) {
                    console.error('Error parsing notes from localStorage:', e);
                    notes = []; // Fallback to empty array if parsing fails
                }
            }

            if (!notes || notes.length === 0) {
                // å¦‚æœæ²¡æœ‰ä¾¿ç­¾ï¼Œåˆ›å»ºé»˜è®¤çš„
                for (let i = 0; i < messages.length; i++) {
                    setTimeout(() => createCard(null, null, null, messages[i]), i * 40); // Pass message as a specific argument
                }
                currentMessageIndex = messages.length % messages.length; // Reset index for future new cards
                return;
            }

            // æ¸…é™¤æ¿ä¸Šæ‰€æœ‰ç°æœ‰ä¾¿ç­¾ï¼Œä»¥ç¡®ä¿ä» localStorage åŠ è½½çš„æ•°æ®æ˜¯å”¯ä¸€çš„æ¥æº
            board.innerHTML = ''; 

            // åˆ›å»ºä¾¿ç­¾å¡ç‰‡
            notes.forEach(cardData => {
                createCard(cardData); // Use the modified createCard function to load data
            });
        }

        /**
         * åˆ›å»ºä¸€ä¸ªæ–°ä¾¿ç­¾æˆ–ä»ç°æœ‰æ•°æ®åŠ è½½ä¾¿ç­¾
         * @param {Object} cardData - å¯é€‰ï¼Œç”¨äºä» localStorage åŠ è½½ä¾¿ç­¾çš„æ•°æ®å¯¹è±¡
         * @param {number} x - å¯é€‰ï¼Œæ–°ä¾¿ç­¾çš„ X åæ ‡ (ä»…åœ¨ cardData ä¸º null æ—¶ä½¿ç”¨)
         * @param {number} y - å¯é€‰ï¼Œæ–°ä¾¿ç­¾çš„ Y åæ ‡ (ä»…åœ¨ cardData ä¸º null æ—¶ä½¿ç”¨)
         * @param {string} messageContentOverride - å¯é€‰ï¼Œè¦†ç›–é»˜è®¤æ¶ˆæ¯å†…å®¹ (ä»…åœ¨ cardData ä¸º null æ—¶ä½¿ç”¨)
         */
        async function createCard(cardData = null, x = null, y = null, messageContentOverride = null) {
            const isNewCard = cardData === null;
            let message = messageContentOverride;

            if (isNewCard) {
                message = messageContentOverride !== null ? messageContentOverride : messages[currentMessageIndex];
                currentMessageIndex = (currentMessageIndex + 1) % messages.length;
            } else {
                // When loading from storage, use the content from cardData
                message = cardData.content;
            }

            const card = document.createElement('div');
            card.className = 'card';

            const color = isNewCard ? randomFrom(colors) : cardData.color;
            const angleRange = isMobile ? 6 : 10;
            const angle = isNewCard ? (Math.random() - 0.5) * angleRange : cardData.angle;
            const entryScale = isMobile ? 0.8 : 0.65;
            const scale = isNewCard ? entryScale : cardData.scale;

            // éšæœºé€‰æ‹©ä¸€ä¸ªåˆå§‹å°ºå¯¸
            const randomDimension = randomFrom(initialCardDimensions);
            const cardWidth = isNewCard ? (isMobile ? 180 : randomDimension.width) : cardData.width;
            // åˆå§‹é«˜åº¦è®¾ç½®ä¸º autoï¼Œè®©å†…å®¹æ’‘å¼€ï¼Œé™¤éæœ‰ä¿å­˜çš„é«˜åº¦
            const cardInitialHeight = isNewCard ? (isMobile ? 130 : randomDimension.height) : (cardData.height || 'auto');

            const horizontalMargin = isMobile ? 12 : 16;
            const verticalMargin = isMobile ? 12 : 20;

            let left, top;
            if (isNewCard) {
                if (x !== null && y !== null) {
                    // å¦‚æœæ˜¯åŒå‡»èƒŒæ™¯åˆ›å»ºï¼Œä½ç½®åœ¨ç‚¹å‡»å¤„é™„è¿‘
                    left = Math.min(Math.max(0, x - cardWidth / 2), window.innerWidth - cardWidth);
                    top = Math.min(Math.max(0, y - (typeof cardInitialHeight === 'number' ? cardInitialHeight : 140) / 2), window.innerHeight - (typeof cardInitialHeight === 'number' ? cardInitialHeight : 140));
                } else {
                    // å¦åˆ™éšæœºä½ç½®
                    left = horizontalMargin +
                        Math.random() *
                        Math.max(window.innerWidth - cardWidth - horizontalMargin * 2, 0);
                    top = verticalMargin +
                        Math.random() *
                        Math.max(window.innerHeight - (typeof cardInitialHeight === 'number' ? cardInitialHeight : 140) - verticalMargin * 2, 0);
                }
            } else {
                left = cardData.left;
                top = cardData.top;
            }

            // Ensure position is within bounds for loaded cards too
            const safeLeft = clamp(left, 0, window.innerWidth - cardWidth);
            const safeTop = clamp(top, 0, window.innerHeight - (typeof cardInitialHeight === 'number' ? cardInitialHeight : 140));


            card.style.background = color;
            card.style.left = `${safeLeft}px`;
            card.style.top = `${safeTop}px`;
            card.style.width = `${cardWidth}px`;
            card.style.height = (typeof cardInitialHeight === 'number' ? `${cardInitialHeight}px` : 'auto'); // Apply saved height or 'auto'
            
            if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER - 2) {
                zIndexCursor = MAXIMIZED_LAYER - 2;
            }
            card.style.zIndex = ++zIndexCursor;

            card.innerHTML = `
                <div class="card-header">
                    <div class="window-controls">
                        <button class="control close" type="button" aria-label="å…³é—­"></button>
                        <button class="control copy" type="button" aria-label="å¤åˆ¶å†…å®¹"></button>
                        <button class="control color-change" type="button" aria-label="æ”¹å˜é¢œè‰²"></button>
                        <button class="control maximize" type="button" aria-label="æœ€å¤§åŒ–"></button>
                    </div>
                    <div class="card-title" contenteditable="false">${cardData ? cardData.title : (messageContentOverride ? 'æ¸©é¦¨æç¤º' : '')}</div>
                </div>
                <div class="card-body-container">
                    <div class="card-body" contenteditable="false">${message || ''}</div>
                    <div class="resize-handle"></div>
                </div>
            `;

            const state = {
                id: cardData ? cardData.id : null, // Use existing ID or null for new card
                angle: angle,
                scale: scale,
                left: safeLeft,
                top: safeTop,
                maximized: cardData ? cardData.maximized : false,
                closing: false,
                currentColorIndex: cardData ? cardData.currentColorIndex : colors.indexOf(color),
                editing: false,
                dragging: false,
                resizing: false,
                dragOffsetX: 0,
                dragOffsetY: 0,
                width: cardWidth,
                height: cardData ? cardData.height : null // Store loaded height or null for auto
            };

            cardStates.set(card, state);
            applyTransform(card, state);
            board.appendChild(card);

            if (isNewCard) {
                await saveCardToLocalStorage(card); // Save new card immediately
            } else {
                // For loaded cards, ensure their state is correctly set up.
                // If a loaded card was maximized, reapply maximized state (visuals only)
                if (state.maximized) {
                    card.classList.add('maximized');
                    card.style.position = 'fixed';
                    card.style.left = '0px';
                    card.style.top = '0px';
                    card.style.width = '100vw';
                    card.style.height = '100dvh';
                    card.style.borderRadius = '0';
                    bringToFront(card);
                    activeMaximizedCard = card;
                    updateBodyMaximizedState();
                    setupEditMode(card); // Re-enable edit mode for maximized card
                }
            }

            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (isNewCard) {
                        state.scale = 1;
                        applyTransform(card, state);
                    }
                    card.style.opacity = '1';
                });
            });

            // é™åˆ¶ä¾¿ç­¾æ•°é‡
            if (isNewCard) { // ä»…å¯¹æ–°åˆ›å»ºçš„ä¾¿ç­¾è¿›è¡Œæ•°é‡é™åˆ¶
                while (board.children.length > maxCards) {
                    const oldest = board.firstElementChild;
                    if (oldest && oldest !== card) {
                        const oldestState = cardStates.get(oldest);
                        // åªæœ‰å½“ä¾¿ç­¾ä¸æ˜¯æœ€å¤§åŒ–çŠ¶æ€ä¸”ä¸æ˜¯æ­£åœ¨å…³é—­æ—¶æ‰ç§»é™¤
                        if (oldestState && !oldestState.maximized && !oldestState.closing) {
                            await deleteCardFromLocalStorage(oldestState.id); // ä» localStorage åˆ é™¤
                            oldest.remove();
                            cardStates.delete(oldest);
                        } else {
                            break; // å¦‚æœæœ€æ—§çš„ä¾¿ç­¾æ˜¯æœ€å¤§åŒ–æˆ–æ­£åœ¨å…³é—­ï¼Œåˆ™åœæ­¢ç§»é™¤
                        }
                    } else {
                        break;
                    }
                }
            }
        }

        async function closeCard(card) {
            const state = cardStates.get(card)
            if (!state || state.closing) return
            if (card === activeMaximizedCard) {
                activeMaximizedCard = null
                updateBodyMaximizedState()
            }
            state.closing = true
            state.scale = 0.1
            card.style.opacity = '0'
            applyTransform(card, state)

            // ä» localStorage åˆ é™¤
            if (state.id) {
                await deleteCardFromLocalStorage(state.id)
            }

            const handleTransitionEnd = event => {
                if (event.propertyName === 'opacity') {
                    card.removeEventListener('transitionend', handleTransitionEnd)
                    card.remove()
                    cardStates.delete(card)
                }
            }

            card.addEventListener('transitionend', handleTransitionEnd)
        }

        async function toggleMaximize(card) {
            const state = cardStates.get(card)
            if (!state || state.closing) return

            if (state.maximized) {
                restoreFromMaximize(card, state)
            } else {
                await maximizeCard(card, state)
            }
        }

        async function maximizeCard(card, state) {
            if (activeMaximizedCard && activeMaximizedCard !== card) {
                const activeState = cardStates.get(activeMaximizedCard)
                if (activeState) {
                    restoreFromMaximize(activeMaximizedCard, activeState)
                }
            }

            state.beforeMaximize = {
                left: state.left,
                top: state.top,
                scale: state.scale ?? 1,
                angle: state.angle ?? 0,
                width: card.offsetWidth,
                height: card.offsetHeight, // ä¿å­˜æœ€å¤§åŒ–å‰çš„é«˜åº¦
                inlinePosition: card.style.position,
                content: card.querySelector('.card-body').innerText,
                title: card.querySelector('.card-title').innerText
            }

            card.classList.add('maximized')
            card.style.position = 'fixed'
            card.style.left = '0px'
            card.style.top = '0px'
            card.style.width = '100vw'
            card.style.height = '100dvh'
            card.style.borderRadius = '0'

            state.left = 0
            state.top = 0
            state.scale = 1
            state.angle = 0
            applyTransform(card, state)
            activeMaximizedCard = card
            bringToFront(card)
            state.maximized = true
            updateBodyMaximizedState()

            await saveCardToLocalStorage(card);
            setupEditMode(card)
        }

        function setupEditMode(card) {
            const title = card.querySelector('.card-title')
            const body = card.querySelector('.card-body')

            title.contentEditable = 'true'
            title.spellcheck = false

            body.contentEditable = 'true'
            body.spellcheck = false

            const editTools = document.createElement('div')
            editTools.className = 'edit-tools'
            editTools.innerHTML = `
                <button class="edit-tool-btn" data-action="strikethrough" title="åˆ é™¤çº¿">S</button>
                <button class="edit-tool-btn" data-action="underline" title="ä¸‹åˆ’çº¿">U</button>
                <button class="edit-tool-btn" data-action="wavy" title="æ³¢æµªçº¿">ã€œ</button>
            `
            // ç¡®ä¿ editTools åªæ·»åŠ ä¸€æ¬¡
            if (!title.parentNode.querySelector('.edit-tools')) {
                title.parentNode.insertBefore(editTools, title.nextSibling)
            }
            
            const autoSave = () => {
                saveCardToLocalStorage(card); 
            }

            title.addEventListener('input', autoSave)
            body.addEventListener('input', autoSave)

            body.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault()
                    const selection = window.getSelection()
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0)
                        const br = document.createElement('br')
                        range.insertNode(br)
                        range.setStartAfter(br)
                        range.collapse(true)
                        selection.removeAllRanges()
                        selection.addRange(range)
                    }
                }
            })
        }

        async function handleEditToolClick(button, card) {
            const action = button.dataset.action
            const body = card.querySelector('.card-body')
            
            // ç¡®ä¿åœ¨æ‰§è¡Œå‘½ä»¤å‰ body æ˜¯ç„¦ç‚¹
            body.focus();

            switch(action) {
                case 'strikethrough':
                    document.execCommand('strikeThrough', false, null)
                    button.classList.toggle('active', body.style.textDecoration.includes('line-through'))
                    break
                case 'underline':
                    document.execCommand('underline', false, null)
                    button.classList.toggle('active', body.style.textDecoration.includes('underline'))
                    break
                case 'wavy':
                    body.classList.toggle('wavy')
                    button.classList.toggle('active', body.classList.contains('wavy'))
                    break
            }
            await saveCardToLocalStorage(card)
        }

        function restoreFromMaximize(card, state) {
            const previous = state.beforeMaximize
            if (!previous) return

            card.classList.remove('maximized')
            card.style.position = previous.inlinePosition || 'absolute'
            card.style.left = `${previous.left}px`
            card.style.top = `${previous.top}px`
            card.style.width = `${previous.width}px`
            card.style.height = previous.height ? `${previous.height}px` : 'auto' // æ¢å¤ä¹‹å‰çš„é«˜åº¦ï¼Œæˆ– auto
            card.style.borderRadius = '12px'

            state.left = previous.left
            state.top = previous.top
            state.scale = previous.scale ?? 1
            state.angle = previous.angle ?? state.angle ?? 0
            state.width = previous.width
            state.height = previous.height // æ¢å¤ä¹‹å‰çš„é«˜åº¦çŠ¶æ€
            applyTransform(card, state)
            state.maximized = false
            if (activeMaximizedCard === card) {
                activeMaximizedCard = null
                updateBodyMaximizedState()
            }
            bringToFront(card)

            const editTools = card.querySelector('.edit-tools')
            if (editTools) editTools.remove()

            const title = card.querySelector('.card-title')
            const body = card.querySelector('.card-body')
            title.contentEditable = 'false'
            body.contentEditable = 'false'

            // æ¸…é™¤æœ€å¤§åŒ–æ—¶çš„æ ·å¼
            body.classList.remove('strikethrough', 'underline', 'wavy')
            // æ¢å¤æ–‡æœ¬è£…é¥°ä¸ºé»˜è®¤å€¼
            body.style.textDecoration = '';

            setTimeout(() => {
                if (!state.maximized) {
                    // ç¡®ä¿åœ¨åŠ¨ç”»ç»“æŸåï¼Œå¦‚æœç”¨æˆ·ä¹‹å‰æ²¡æœ‰è®¾ç½®è¿‡é«˜åº¦ï¼Œåˆ™æ¢å¤ä¸º auto
                    if (state.height === null) {
                        card.style.height = 'auto';
                    } else {
                        card.style.height = `${state.height}px`;
                    }
                    card.style.width = `${state.width}px`
                    card.style.borderRadius = ''
                    if (previous.inlinePosition) {
                        card.style.position = previous.inlinePosition
                    } else {
                        card.style.position = ''
                    }
                    state.beforeMaximize = null
                }
            }, 360)
        }

        async function startDrag(event, card) {
            const control = event.target.closest('.control, .edit-tool-btn, .resize-handle')
            if (control) return

            const state = cardStates.get(card)
            if (!state || state.closing || state.maximized || state.editing) return

            event.preventDefault()
            bringToFront(card)

            card.classList.add('dragging')

            state.dragging = true
            state.dragOffsetX = event.clientX - state.left
            state.dragOffsetY = event.clientY - state.top

            let dragFrame = null
            let pendingLeft = state.left
            let pendingTop = state.top

            const commitDrag = async () => {
                dragFrame = null
                // ç¡®ä¿ä¾¿ç­¾ä¸ä¼šå®Œå…¨æ‹–å‡ºå±å¹•
                const maxLeft = window.innerWidth - card.offsetWidth
                const maxTop = window.innerHeight - card.offsetHeight
                state.left = clamp(pendingLeft, -card.offsetWidth * 0.4, maxLeft + card.offsetWidth * 0.4) // å…è®¸éƒ¨åˆ†æ‹–å‡º
                state.top = clamp(pendingTop, -card.offsetHeight * 0.4, maxTop + card.offsetHeight * 0.4) // å…è®¸éƒ¨åˆ†æ‹–å‡º
                card.style.left = `${state.left}px`
                card.style.top = `${state.top}px`
                
                await saveCardToLocalStorage(card)
            }

            const handlePointerMove = moveEvent => {
                if (!state.dragging) return

                pendingLeft = moveEvent.clientX - state.dragOffsetX
                pendingTop = moveEvent.clientY - state.dragOffsetY
                if (dragFrame === null) {
                    dragFrame = requestAnimationFrame(commitDrag)
                }
            }

            const handlePointerUp = () => {
                state.dragging = false
                card.classList.remove('dragging')
                if (dragFrame !== null) {
                    cancelAnimationFrame(dragFrame)
                    commitDrag()
                } else {
                    // å¦‚æœæ²¡æœ‰ç§»åŠ¨ï¼Œä¹Ÿæäº¤ä¸€æ¬¡ï¼Œç¡®ä¿ä½ç½®æ›´æ–°
                    commitDrag();
                }
                document.removeEventListener('pointermove', handlePointerMove)
                document.removeEventListener('pointerup', handlePointerUp)
            }

            document.addEventListener('pointermove', handlePointerMove)
            document.addEventListener('pointerup', handlePointerUp)
        }

        async function cycleCardColor(card) {
            const state = cardStates.get(card)
            if (!state || state.closing) return

            let currentIndex = state.currentColorIndex !== undefined ? state.currentColorIndex : -1
            const nextIndex = (currentIndex + 1) % colors.length
            const newColor = colors[nextIndex]

            card.style.background = newColor
            state.currentColorIndex = nextIndex
            
            await saveCardToLocalStorage(card)
        }

        // é¡µé¢åŠ è½½æ—¶ä» localStorage æ¢å¤ä¾¿ç­¾
        window.addEventListener('DOMContentLoaded', () => {
            loadCardsFromLocalStorage();
        })

        if (typeof pointerMediaQuery.addEventListener === 'function') {
            pointerMediaQuery.addEventListener('change', syncMobileMode)
        } else if (typeof pointerMediaQuery.addListener === 'function') {
            pointerMediaQuery.addListener(syncMobileMode)
        }

        window.addEventListener('resize', syncMobileMode)

        let isDarkMode = false

        function setDarkMode(enable) {
            if (enable) {
                document.body.classList.add('dark-mode')
                document.body.classList.remove('light-mode')
                themeToggleButton.innerHTML = 'â˜€'
                themeToggleButton.setAttribute('aria-label', 'åˆ‡æ¢åˆ°äº®è‰²æ¨¡å¼')
                isDarkMode = true
            } else {
                document.body.classList.remove('dark-mode')
                document.body.classList.add('light-mode')
                themeToggleButton.innerHTML = 'ğŸŒ™'
                themeToggleButton.setAttribute('aria-label', 'åˆ‡æ¢åˆ°æš—è‰²æ¨¡å¼')
                isDarkMode = false
            }
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light')
        }

        const savedTheme = localStorage.getItem('theme')
        if (savedTheme === 'dark' || savedTheme === null) {
            setDarkMode(true)
        } else {
            setDarkMode(false)
        }

        // æ·»åŠ å…¨å±€é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨äºæ¡†é€‰åŠŸèƒ½
        document.addEventListener('pointerdown', handleGlobalPointerDown)
    </script>
</body>
</html>